import { BuildData, Client } from "../BuildData";
import { buildClient, createObject } from "./classes";
import { createEnum, createException, sharedCode } from "./shared";

// Defines the header which contains the base classes for the generated clients.
const header = `# This file is auto-generated by arpc. Do not edit manually!

import msgpack
import typing
import urllib.parse
import requests

${sharedCode(false)}


def _process_result(resp: requests.Response, batch):
    """Processes the result of a request."""
    if resp.headers.get("x-is-arpc") != "true":
        raise InvalidResponse("INVALID_RESPONSE", "The response is not an arpc response.")

    if resp.status_code == 204:
        return None if batch is None else [None] * len(batch)

    try:
        body = msgpack.unpackb(resp.content, raw=False)
    except ValueError:
        raise InvalidResponse("INVALID_RESPONSE", "The response is not a valid msgpack response.")

    if resp.status_code == 200:
        if not batch:
            return body
        return _process_batch(body, batch)

    if isinstance(body, list):
        errors = []
        for error in body:
            try:
                _throw(error)
            except Exception as e:
                errors.append(e)
        raise BatchError(errors)

    _throw(body)


class _BaseClient(object):
    """Defines the base client that all clients inherit from."""
    def __init__(self, url_params: str, hostname: str, init_headers):
        self._url_params = url_params
        self._hostname = hostname
        self._init_headers = init_headers

    def _do_request(self, request: typing.Union[_Request, _BaseBatcher]):
        """Executes a request."""
        m = "POST"
        headers = self._init_headers.copy()
        kwargs = {}
        batch = None
        if isinstance(request, _Request):
            # Handle a single request.
            params = self._url_params + "&route=" + urllib.parse.quote_plus(request.method)
            if request.mutation:
                # Send the msgpack as the body.
                headers["Content-Type"] = "application/msgpack"
                kwargs["data"] = msgpack.packb(request.arg)
            else:
                # Include the argument in the query string.
                m = "GET"
                arg = urllib.parse.quote_plus(msgpack.packb(request.arg))
                params = params + f"&arg={arg}"
        else:
            # Handle a batch request.
            batch = request._batch
            params = self._url_params + "&route=batch"
            data = msgpack.packb([{"methodName": req[0].method, "arg": req[0].arg} for req in batch])
            if _all_non_mutation(batch):
                # Include the argument in the query string.
                m = "GET"
                arg = urllib.parse.quote_plus(data)
                params = params + f"&arg={arg}"
            else:
                # Send the msgpack as the body.
                headers["Content-Type"] = "application/msgpack"
                kwargs["data"] = data

        resp = requests.request(m, self._hostname + "/api/rpc?" + params, headers=headers, **kwargs)
        return _process_result(resp, batch)`;

// Defines the __init__ generation function.
function initGen(client: Client) {
    // Defines the shared init code for all branches.
    const superInit = `
        hostname = hostname or "${client.defaultProtocol}://${client.defaultHostname}"
        parsed = urllib.parse.urlparse(hostname)
        if parsed.scheme:
            hostname = parsed.scheme + "://" + parsed.netloc
        else:
            hostname = "${client.defaultProtocol}://" + hostname
        
        super().__init__("version=${client.apiVersion}", hostname, init_headers)`;

    // Handle the no auth case.
    if (!client.authentication) {
        return `    def __init__(self, hostname: str = None):
        init_headers = {}${superInit}`;
    }

    // Build the type for the token types.
    const humanNames = Object.keys(client.authentication.tokenTypes).sort();
    const defaultTokenType = client.authentication.defaultTokenType ? `"${client.authentication.defaultTokenType}"` : "None";
    const tokenType = `token_type: typing.Literal[${humanNames.map((x) => `"${x}"`).join(", ")}] = ${defaultTokenType}`;
    let pythonDict = "{";
    for (const name of humanNames) {
        pythonDict += `"${name}": "${client.authentication.tokenTypes[name]}", `;
    }
    pythonDict = pythonDict.slice(0, -2) + "}";

    // Handle the auth case.
    return `    def __init__(self, token: str = None, ${tokenType}, hostname: str = None):
        init_headers = {}
        if token:
            token_type_map = ${pythonDict}
            if token_type not in token_type_map:
                raise ValueError(f"Invalid token type: {token_type}")
            init_headers = {"Authorization": f"{token_type_map[token_type]} {token}"}
${superInit}`;
}

// Defines the function to generate the client.
export function pythonSync(data: BuildData) {
    const chunks = [header];

    for (const e of data.enums) {
        chunks.push(createEnum(e));
    }

    for (const o of data.objects) {
        chunks.push(createObject(o, data.enums));
    }

    for (const e of data.builtinExceptions) {
        chunks.push(createException(e.name, e.description, true));
    }

    for (const e of data.customExceptions) {
        chunks.push(createException(e.name, e.description, false));
    }

    for (const c of data.clients) {
        chunks.push(buildClient(false, data.enums, c, initGen));
    }

    return chunks.join("\n\n\n") + "\n";
}
