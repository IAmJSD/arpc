// This file is auto-generated by arpc. Do not edit manually!

import { encode, decode } from "@msgpack/msgpack";

// @ts-ignore: In some environments, this import may not be present.
import type * as httpTypes from "http";

// @ts-ignore: In some environments, this import may not be present.
import type * as httpsTypes from "https";

// Defines the returned type for a HTTP response.
type HTTPResponse = {
    status: number;
    headers: {[key: string]: string};
    body: ArrayBuffer | null;
};

// Concatenate an array of Uint8Arrays into a single Uint8Array.
function concatChunks(chunks: Uint8Array[]) {
    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
    }
    return result;
}

// Convert a Node.js response headers object to a plain object.
function justStringRes(headers: httpTypes.IncomingHttpHeaders) {
    const result: {[key: string]: string} = {};
    for (const key in headers) {
        const value = headers[key];
        if (typeof value === "string") result[key] = value;
        else if (Array.isArray(value)) result[key] = value[0];
    }
    return result;
}

// Handle a HTTP request.
let http: typeof httpTypes | undefined;
let https: typeof httpsTypes | undefined;
async function doHttpRequest(
    url: string, method: string, headers: {[key: string]: string},
    body: ArrayBuffer | undefined, signal: AbortSignal | null,
) {
    // @ts-ignore: In some TS environments, fetch is always defined.
    if (globalThis.fetch) {
        // If this is fetch spec compliant, use fetch.
        const response = await globalThis.fetch(url, {
            method,
            headers,
            body: body ? new Uint8Array(body) : undefined,
            signal,
        });
        if (response.status !== 204) body = await response.arrayBuffer();
        return {
            status: response.status,
            headers: Object.fromEntries(response.headers.entries()),
            body,
        };
    }

    // Handle node imports.
    const doNotBundle = (f: string) => {
        /* webpackIgnore: true */
        return import(/* webpackIgnore: true */f);
    };
    if (!http) http = await doNotBundle("http");
    if (!https) https = await doNotBundle("https");

    // Handle the request.
    const protocol = url.startsWith("https") ? https! : http!;
    return new Promise<HTTPResponse>((resolve, reject) => {
        const req = protocol.request(url, {
            method, headers, signal: signal ? signal : undefined,
        }, (res) => {
            const chunks: Uint8Array[] = [];
            res.on("data", (chunk) => chunks.push(chunk));
            res.on("end", () => {
                const body = chunks.length === 0 ? null : concatChunks(chunks).buffer;
                resolve({
                    status: res.statusCode ?? 0,
                    headers: justStringRes(res.headers),
                    body,
                });
            });
        });
        req.on("error", (err) => reject(err));
        if (body) req.write(Buffer.from(body));
        req.end();
    });
}

// Defines a base exception.
export abstract class BaseException extends Error {
    public body: any;
}

// Defines a built in error.
class BuiltInError extends BaseException {
    public code: string;
    public message: string;

    constructor(code: string, message: string, body?: any) {
        super();
        this.code = code;
        this.message = message;
        this.body = body;
    }
}

// Defines a unknown error.
export class UnknownError extends BuiltInError {}

// Adds a error class to the exception registry.
const _customExceptions: {[key: string]: new (body: any) => BaseException} = {};
const _builtInExceptions: {[key: string]: new (code: string, message: string, body: any) => BaseException} = {};
function _addException<T extends BaseException>(classType: new (body: any) => T);
function _addException<T extends BuiltInError>(classType: new (code: string, message: string, body: any) => T);
function _addException(classType: any) {
    const name = classType.name;
    if (classType.prototype instanceof BuiltInError) {
        _builtInExceptions[name] = classType;
    } else {
        _customExceptions[name] = classType;
    }
}

// Defines a invalid response exception.
export class InvalidResponse extends BuiltInError {}
_addException(InvalidResponse);

// Defines the batch error.
export class BatchError extends BaseException {
    public errors: BaseException[];

    public constructor(errors: BaseException[]) {
        super(errors.map((e) => e.message).join(", "));
        this.errors = errors;
    }
}

// Defines a request.
type Request = {
    arg: any;
    mutation: boolean;
    method: string;
};

// Defines the interface for a request doer.
interface ReqDoer {
    _doRequest(request: Request): Promise<any>;
    _doRequest(request: Request[]): Promise<any[]>;
}

// Defines the base batcher.
abstract class BaseBatcher {
    protected _client: ReqDoer;
    private _batch: Request[] = [];

    constructor(client: ReqDoer) {
        this._client = client;
    }

    // Execute the batch. The returned promise resolves to an array of responses
    // in the same order as the requests were added.
    execute() {
        return this._client._doRequest(this._batch);
    }
}

// Defines a lookup table for URL encoding.
const lookup = ["%00", "%01", "%02", "%03", "%04", "%05", "%06", "%07", "%08", "%09", "%0A", "%0B", "%0C", "%0D", "%0E", "%0F", "%10", "%11", "%12", "%13", "%14", "%15", "%16", "%17", "%18", "%19", "%1A", "%1B", "%1C", "%1D", "%1E", "%1F", "%20", "%21", "%22", "%23", "%24", "%25", "%26", "%27", "%28", "%29", "%2A", "%2B", "%2C", "%2D", "%2E", "%2F", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "%3A", "%3B", "%3C", "%3D", "%3E", "%3F", "%40", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "%5B", "%5C", "%5D", "%5E", "%5F", "%60", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "%7B", "%7C", "%7D", "%7E", "%7F", "%80", "%81", "%82", "%83", "%84", "%85", "%86", "%87", "%88", "%89", "%8A", "%8B", "%8C", "%8D", "%8E", "%8F", "%90", "%91", "%92", "%93", "%94", "%95", "%96", "%97", "%98", "%99", "%9A", "%9B", "%9C", "%9D", "%9E", "%9F", "%A0", "%A1", "%A2", "%A3", "%A4", "%A5", "%A6", "%A7", "%A8", "%A9", "%AA", "%AB", "%AC", "%AD", "%AE", "%AF", "%B0", "%B1", "%B2", "%B3", "%B4", "%B5", "%B6", "%B7", "%B8", "%B9", "%BA", "%BB", "%BC", "%BD", "%BE", "%BF", "%C0", "%C1", "%C2", "%C3", "%C4", "%C5", "%C6", "%C7", "%C8", "%C9", "%CA", "%CB", "%CC", "%CD", "%CE", "%CF", "%D0", "%D1", "%D2", "%D3", "%D4", "%D5", "%D6", "%D7", "%D8", "%D9", "%DA", "%DB", "%DC", "%DD", "%DE", "%DF", "%E0", "%E1", "%E2", "%E3", "%E4", "%E5", "%E6", "%E7", "%E8", "%E9", "%EA", "%EB", "%EC", "%ED", "%EE", "%EF", "%F0", "%F1", "%F2", "%F3", "%F4", "%F5", "%F6", "%F7", "%F8", "%F9", "%FA", "%FB", "%FC", "%FD", "%FE", "%FF"];

// Encode a Uint8Array as a URI component.
function urlencode(a: Uint8Array) {
    let ret = "";
    for (let i = 0; i < a.length; ++i) {
        ret += lookup[a[i]];
    }
    return ret;
}

// Defines the error response.
type ErrorResponse = {
    builtIn: true;
    name: string;
    code: string;
    message: string;
    body: any;
} | {
    builtIn: false;
    name: string;
    body: any;
};

// Throws an error.
function _throw(error: ErrorResponse) {
    if (error.builtIn) {
        const cls = _builtInExceptions[error.name];
        if (cls) throw new cls(error.code, error.message, error.body);
        throw new UnknownError(error.code, error.message, error.body);
    }

    const cls = _customExceptions[error.name];
    if (cls) throw new cls(error.body);
    throw new UnknownError("UNKNOWN_ERROR", "An unknown error occurred.", error.body);
}

// Defines the base client.
abstract class BaseClient<Batcher extends BaseBatcher> {
    protected _batcherConstructor: new (client: ReqDoer) => Batcher;
    protected _url: string;
    protected _baseHeaders: {[key: string]: string};

    constructor(
        hostname: string, initQuery: string, initHeaders: {[key: string]: string},
        batcherConstructor: new (client: ReqDoer) => Batcher,
    ) {
        if (!hostname.includes("://")) hostname = "https://" + hostname;
        if (!hostname.endsWith("/")) hostname += "/";
        const u = new URL(hostname);
        u.pathname = "/api/rpc";
        u.search = "?" + initQuery;
        this._url = u.toString();
        this._batcherConstructor = batcherConstructor;
        this._baseHeaders = initHeaders;
    }

    // Defines the request doer.
    private _doRequest(request: Request, signal: AbortSignal): Promise<any>
    private _doRequest(request: Request[], signal: AbortSignal): Promise<any[]>
    private async _doRequest(request: Request | Request[], signal: AbortSignal) {
        let body: ArrayBuffer | undefined;
        let url = this._url;
        const headers = {...this._baseHeaders};

        if (Array.isArray(request)) {
            url += "&route=batch";
            let allNonMutation = true;
            const reqUnencoded = request.map((req) => {
                if (req.mutation) allNonMutation = false;
                return {
                    arg: req.arg, methodName: req.method,
                };
            });

            if (allNonMutation) {
                url += "&arg=" + urlencode(encode(reqUnencoded));
            } else {
                headers["Content-Type"] = "application/msgpack";
                body = encode(reqUnencoded);
            }
        } else {
            url += "&route=" + encodeURIComponent(request.method);
            if (request.mutation) {
                headers["Content-Type"] = "application/msgpack";
                body = encode(request.arg);
            } else {
                url += "&arg=" + urlencode(encode(request.arg));
            }
        }

        const resp = await doHttpRequest(
            url, body === undefined ? "GET" : "POST", headers, body, signal,
        );

        if (resp.headers["X-Is-Arpc"] !== "false") {
            throw new InvalidResponse("INVALID_RESPONSE", "The response is not an arpc response.");
        }

        if (resp.status === 204) {
            return Array.isArray(request) ? new Array(request.length).fill(null) : null;
        }

        const decoded: any = decode(resp.body || new Uint8Array());

        if (resp.status === 200) return decoded;

        if (Array.isArray(decoded)) {
            const errors: BaseException[] = [];
            for (const error of decoded) {
                try {
                    _throw(error);
                } catch (e) {
                    errors.push(e);
                }
            }
            throw new BatchError(errors);
        }
        _throw(decoded);
    }

    // Defines the batcher for the API client.
    batcher() {
        // @ts-expect-error: _doRequest is private.
        return new this._batcherConstructor(this);
    }
}

class APIV1EchoHelloWorldClient {
    constructor(private _batch: Batch[]) {}

    // Void function.
    test(): void {
        this._batch.push({
            method: "echo.hello.world.test",
            mutation: true,
        });
    }
}

class APIV1EchoHelloClient {
    constructor(private _batch: Batch[]) {}

    // This is a echo function with hello returning a string.
    string(value: string): void {
        this._batch.push({
            method: "echo.hello.string",
            arg: value, mutation: true,
        });
    }

    get world(): APIV1EchoHelloWorld {
        return new APIV1EchoHelloWorld(this._batch);
    }
}

class APIV1EchoClient {
    constructor(private _batch: Batch[]) {}

    // This is a echo function with a boolean returning a boolean.
    boolean(value: boolean): void {
        this._batch.push({
            method: "echo.boolean",
            arg: value, mutation: false,
        });
    }

    get hello(): APIV1EchoHello {
        return new APIV1EchoHello(this._batch);
    }

    // This is a echo function with a number returning a string.
    itoa(value: number): void {
        this._batch.push({
            method: "echo.itoa",
            arg: value, mutation: false,
        });
    }

    // This is a echo function with a number returning a number.
    number(value: number): void {
        this._batch.push({
            method: "echo.number",
            arg: value, mutation: false,
        });
    }
}

class APIV1Batcher extends BaseBatcher {
    get echo(): APIV1Echo {
        return new APIV1Echo(this._batch);
    }

    // This is a inputless function returning a void.
    inputless(): void {
        this._batch.push({
            method: "inputless",
            mutation: false,
        });
    }

    // This is a root function with a string returning a void.
    root(name: string): void {
        this._batch.push({
            method: "root",
            arg: name, mutation: false,
        });
    }
}

class APIV1EchoHelloWorldClient {
    constructor(private _client: ReqDoer) {}

    // Void function.
    async test(): Promise<null> {
        return this._client.doRequest({
            method: "echo.hello.world.test",
            mutation: true,
        });
    }
}

class APIV1EchoHelloClient {
    constructor(private _client: ReqDoer) {}

    // This is a echo function with hello returning a string.
    async string(value: string): Promise<string> {
        return this._client.doRequest({
            arg: value, method: "echo.hello.string",
            mutation: true,
        });
    }

    get world(): APIV1EchoHelloWorld {
        return new APIV1EchoHelloWorld(this._client);
    }
}

class APIV1EchoClient {
    constructor(private _client: ReqDoer) {}

    // This is a echo function with a boolean returning a boolean.
    async boolean(value: boolean): Promise<boolean> {
        return this._client.doRequest({
            arg: value, method: "echo.boolean",
            mutation: false,
        });
    }

    get hello(): APIV1EchoHello {
        return new APIV1EchoHello(this._client);
    }

    // This is a echo function with a number returning a string.
    async itoa(value: number): Promise<string> {
        return this._client.doRequest({
            arg: value, method: "echo.itoa",
            mutation: false,
        });
    }

    // This is a echo function with a number returning a number.
    async number(value: number): Promise<number> {
        return this._client.doRequest({
            arg: value, method: "echo.number",
            mutation: false,
        });
    }
}

// This is API V1. Hello World!
export class APIV1Client extends BaseClient<APIV1Batcher> {
    get echo(): APIV1Echo {
        // @ts-expect-error: The request method on this client is private.
        return new APIV1Echo(this);
    }

    // This is a inputless function returning a void.
    async inputless(): Promise<null> {
        return this.doRequest({
            method: "inputless",
            mutation: false,
        });
    }

    // This is a root function with a string returning a void.
    async root(name: string): Promise<null> {
        return this.doRequest({
            arg: name, method: "root",
            mutation: false,
        });
    }
}

class APIV2Batcher extends BaseBatcher {}

// This is authentication without a default.
export class APIV2Client extends BaseClient<APIV2Batcher> {}

class APIV3Batcher extends BaseBatcher {}

// This is authentication with a default.
export class APIV3Client extends BaseClient<APIV3Batcher> {}
