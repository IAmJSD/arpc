// This file is auto-generated by arpc. Do not edit manually!

import { encode, decode } from "@msgpack/msgpack";

// @ts-ignore: In some environments, this import may not be present.
import type * as httpTypes from "http";

// @ts-ignore: In some environments, this import may not be present.
import type * as httpsTypes from "https";

// Defines the returned type for a HTTP response.
type HTTPResponse = {
    status: number;
    headers: {[key: string]: string};
    body: ArrayBuffer | null;
};

// Concatenate an array of Uint8Arrays into a single Uint8Array.
function concatChunks(chunks: Uint8Array[]) {
    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
    }
    return result;
}

// Convert a Node.js response headers object to a plain object.
function justStringRes(headers: httpTypes.IncomingHttpHeaders) {
    const result: {[key: string]: string} = {};
    for (const key in headers) {
        const value = headers[key];
        if (typeof value === "string") result[key] = value;
        else if (Array.isArray(value)) result[key] = value[0];
    }
    return result;
}

// Handle a HTTP request.
let http: typeof httpTypes | undefined;
let https: typeof httpsTypes | undefined;
async function doHttpRequest(
    url: string, method: string, headers: {[key: string]: string},
    body: ArrayBuffer | undefined, signal: AbortSignal | undefined,
) {
    // @ts-ignore: In some TS environments, fetch is always defined.
    if (globalThis.fetch) {
        // If this is fetch spec compliant, use fetch.
        const response = await globalThis.fetch(url, {
            method,
            headers,
            body: body ? new Uint8Array(body) : undefined,
            signal,
        });
        if (response.status !== 204) body = await response.arrayBuffer();
        return {
            status: response.status,
            headers: Object.fromEntries(response.headers.entries()),
            body,
        };
    }

    // Handle node imports.
    const doNotBundle = (f: string) => {
        /* webpackIgnore: true */
        return import(/* webpackIgnore: true */f);
    };
    if (!http) http = await doNotBundle("http");
    if (!https) https = await doNotBundle("https");

    // Handle the request.
    const protocol = url.startsWith("https") ? https! : http!;
    return new Promise<HTTPResponse>((resolve, reject) => {
        const req = protocol.request(url, {
            method, headers, signal: signal ? signal : undefined,
        }, (res) => {
            const chunks: Uint8Array[] = [];
            res.on("data", (chunk) => chunks.push(chunk));
            res.on("end", () => {
                const body = chunks.length === 0 ? null : concatChunks(chunks).buffer;
                resolve({
                    status: res.statusCode ?? 0,
                    headers: justStringRes(res.headers),
                    body,
                });
            });
        });
        req.on("error", (err) => reject(err));
        if (body) req.write(Buffer.from(body));
        req.end();
    });
}

// Defines a base exception.
export abstract class BaseException extends Error {
    public body: any;
}

// Defines a built in error.
class BuiltInError extends BaseException {
    public code: string;
    public message: string;

    constructor(code: string, message: string, body?: any) {
        super();
        this.code = code;
        this.message = message;
        this.body = body;
    }
}

// Defines a unknown error.
export class UnknownError extends BuiltInError {}

// Adds a error class to the exception registry.
const _customExceptions: {[key: string]: new (body: any) => BaseException} = {};
const _builtInExceptions: {[key: string]: new (code: string, message: string, body: any) => BaseException} = {};
function _addException<T extends BaseException>(classType: new (body: any) => T);
function _addException<T extends BuiltInError>(classType: new (code: string, message: string, body: any) => T);
function _addException(classType: any) {
    const name = classType.name;
    if (classType.prototype instanceof BuiltInError) {
        _builtInExceptions[name] = classType;
    } else {
        _customExceptions[name] = classType;
    }
}

// Defines a invalid response exception.
export class InvalidResponse extends BuiltInError {}
_addException(InvalidResponse);

// Defines the batch error.
export class BatchError extends BaseException {
    public errors: BaseException[];

    public constructor(errors: BaseException[]) {
        super(errors.map((e) => e.message).join(", "));
        this.errors = errors;
    }
}

// Defines a request.
type Request<T> = {
    arg: any;
    mutation: boolean;
    method: string;
};

// Makes a new array type with T being the type of each element in A.
type ExtractTypes<A extends Request<any>[]> = {
    [K in keyof A]: A[K] extends Request<infer T> ? T : never;
};

// Defines the interface for a request doer.
interface ReqDoer {
    _doRequest(request: Request<any>, signal: AbortSignal | undefined): Promise<any>;
    _doRequest(request: Request<any>[], signal: AbortSignal | undefined): Promise<any[]>;
}

// Defines a lookup table for URL encoding.
const lookup = ["%00", "%01", "%02", "%03", "%04", "%05", "%06", "%07", "%08", "%09", "%0A", "%0B", "%0C", "%0D", "%0E", "%0F", "%10", "%11", "%12", "%13", "%14", "%15", "%16", "%17", "%18", "%19", "%1A", "%1B", "%1C", "%1D", "%1E", "%1F", "%20", "%21", "%22", "%23", "%24", "%25", "%26", "%27", "%28", "%29", "%2A", "%2B", "%2C", "%2D", "%2E", "%2F", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "%3A", "%3B", "%3C", "%3D", "%3E", "%3F", "%40", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "%5B", "%5C", "%5D", "%5E", "%5F", "%60", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "%7B", "%7C", "%7D", "%7E", "%7F", "%80", "%81", "%82", "%83", "%84", "%85", "%86", "%87", "%88", "%89", "%8A", "%8B", "%8C", "%8D", "%8E", "%8F", "%90", "%91", "%92", "%93", "%94", "%95", "%96", "%97", "%98", "%99", "%9A", "%9B", "%9C", "%9D", "%9E", "%9F", "%A0", "%A1", "%A2", "%A3", "%A4", "%A5", "%A6", "%A7", "%A8", "%A9", "%AA", "%AB", "%AC", "%AD", "%AE", "%AF", "%B0", "%B1", "%B2", "%B3", "%B4", "%B5", "%B6", "%B7", "%B8", "%B9", "%BA", "%BB", "%BC", "%BD", "%BE", "%BF", "%C0", "%C1", "%C2", "%C3", "%C4", "%C5", "%C6", "%C7", "%C8", "%C9", "%CA", "%CB", "%CC", "%CD", "%CE", "%CF", "%D0", "%D1", "%D2", "%D3", "%D4", "%D5", "%D6", "%D7", "%D8", "%D9", "%DA", "%DB", "%DC", "%DD", "%DE", "%DF", "%E0", "%E1", "%E2", "%E3", "%E4", "%E5", "%E6", "%E7", "%E8", "%E9", "%EA", "%EB", "%EC", "%ED", "%EE", "%EF", "%F0", "%F1", "%F2", "%F3", "%F4", "%F5", "%F6", "%F7", "%F8", "%F9", "%FA", "%FB", "%FC", "%FD", "%FE", "%FF"];

// Encode a Uint8Array as a URI component.
function urlencode(a: Uint8Array) {
    let ret = "";
    for (let i = 0; i < a.length; ++i) {
        ret += lookup[a[i]];
    }
    return ret;
}

// Defines the error response.
type ErrorResponse = {
    builtIn: true;
    name: string;
    code: string;
    message: string;
    body: any;
} | {
    builtIn: false;
    name: string;
    body: any;
};

// Throws an error.
function _throw(error: ErrorResponse) {
    if (error.builtIn) {
        const cls = _builtInExceptions[error.name];
        if (cls) throw new cls(error.code, error.message, error.body);
        throw new UnknownError(error.code, error.message, error.body);
    }

    const cls = _customExceptions[error.name];
    if (cls) throw new cls(error.body);
    throw new UnknownError("UNKNOWN_ERROR", "An unknown error occurred.", error.body);
}

// Defines the base client.
abstract class BaseClient<Batcher> {
    protected _batcherConstructor: new () => Batcher;
    protected _url: string;
    protected _baseHeaders: {[key: string]: string};

    constructor(
        hostname: string, initQuery: string, initHeaders: {[key: string]: string},
        batcherConstructor: new () => Batcher,
    ) {
        if (!hostname.includes("://")) hostname = "https://" + hostname;
        if (!hostname.endsWith("/")) hostname += "/";
        const u = new URL(hostname);
        u.pathname = "/api/rpc";
        u.search = "?" + initQuery;
        this._url = u.toString();
        this._batcherConstructor = batcherConstructor;
        this._baseHeaders = initHeaders;
    }

    // Defines the request doer.
    protected _doRequest(request: Request<any>, signal: AbortSignal | undefined): Promise<any>
    protected _doRequest<A extends Request<any>[]>(request: A, signal: AbortSignal | undefined): Promise<ExtractTypes<A>>
    protected async _doRequest(request: Request<any> | Request<any>[], signal: AbortSignal | undefined) {
        let body: ArrayBuffer | undefined;
        let url = this._url;
        const headers = {...this._baseHeaders};

        if (Array.isArray(request)) {
            url += "&route=batch";
            let allNonMutation = true;
            const reqUnencoded = request.map((req) => {
                if (req.mutation) allNonMutation = false;
                return {
                    arg: req.arg, methodName: req.method,
                };
            });

            if (allNonMutation) {
                url += "&arg=" + urlencode(encode(reqUnencoded));
            } else {
                headers["Content-Type"] = "application/msgpack";
                body = encode(reqUnencoded);
            }
        } else {
            url += "&route=" + encodeURIComponent(request.method);
            if (request.mutation) {
                headers["Content-Type"] = "application/msgpack";
                body = encode(request.arg);
            } else {
                url += "&arg=" + urlencode(encode(request.arg));
            }
        }

        const resp = await doHttpRequest(
            url, body === undefined ? "GET" : "POST", headers, body, signal,
        );

        if (resp.headers["X-Is-Arpc"] !== "false") {
            throw new InvalidResponse("INVALID_RESPONSE", "The response is not an arpc response.");
        }

        if (resp.status === 204) {
            return Array.isArray(request) ? new Array(request.length).fill(null) : null;
        }

        const decoded: any = decode(resp.body || new Uint8Array());

        if (resp.status === 200) return decoded;

        if (Array.isArray(decoded)) {
            const errors: BaseException[] = [];
            for (const error of decoded) {
                try {
                    _throw(error);
                } catch (e) {
                    errors.push(e);
                }
            }
            throw new BatchError(errors);
        }
        _throw(decoded);
    }

    // Defines the batch creator.
    async batch<A extends Request<any>[]>(
        fn: (batcher: Batcher) => Promise<A> | A, signal?: AbortSignal,
    ): Promise<ExtractTypes<A>> {
        const batcher = new this._batcherConstructor();
        const requests = await fn(batcher);
        return this._doRequest(requests, signal);
    }
}

class APIV1EchoHelloWorldBatcher {
    /**
    Void function.
    */
    test(): Request<null> {
        return {
            method: "echo.hello.world.test",
            arg: null, mutation: true,
        };
    }
}

class APIV1EchoHelloBatcher {
    /**
    This is a echo function with hello returning a string.
    */
    string(value: string): Request<string> {
        return {
            method: "echo.hello.string",
            arg: value, mutation: true,
        };
    }

    get world(): APIV1EchoHelloWorldBatcher {
        return new APIV1EchoHelloWorldBatcher();
    }
}

class APIV1EchoBatcher {
    /**
    This is a echo function with a boolean returning a boolean.
    */
    boolean(value: boolean): Request<boolean> {
        return {
            method: "echo.boolean",
            arg: value, mutation: false,
        };
    }

    get hello(): APIV1EchoHelloBatcher {
        return new APIV1EchoHelloBatcher();
    }

    /**
    This is a echo function with a number returning a string.
    */
    itoa(value: number): Request<string> {
        return {
            method: "echo.itoa",
            arg: value, mutation: false,
        };
    }

    /**
    This is a echo function with a number returning a number.
    */
    number(value: number): Request<number> {
        return {
            method: "echo.number",
            arg: value, mutation: false,
        };
    }
}

class APIV1Batcher {
    get echo(): APIV1EchoBatcher {
        return new APIV1EchoBatcher();
    }

    /**
    This is a inputless function returning a void.
    */
    inputless(): Request<null> {
        return {
            method: "inputless",
            arg: null, mutation: false,
        };
    }

    /**
    This is a root function with a string returning a void.
    */
    root(name: string): Request<null> {
        return {
            method: "root",
            arg: name, mutation: false,
        };
    }
}

class APIV1EchoHelloWorldClient {
    constructor(private _client: ReqDoer) {}

    /**
    Void function.
    */
    async test(abortSignal?: AbortSignal): Promise<null> {
        return this._client._doRequest({
            arg: null, method: "echo.hello.world.test",
            mutation: true,
        }, abortSignal);
    }
}

class APIV1EchoHelloClient {
    constructor(private _client: ReqDoer) {}

    /**
    This is a echo function with hello returning a string.
    */
    async string(value: string, abortSignal?: AbortSignal): Promise<string> {
        return this._client._doRequest({
            arg: value, method: "echo.hello.string",
            mutation: true,
        }, abortSignal);
    }

    get world(): APIV1EchoHelloWorldClient {
        return new APIV1EchoHelloWorldClient(this._client);
    }
}

class APIV1EchoClient {
    constructor(private _client: ReqDoer) {}

    /**
    This is a echo function with a boolean returning a boolean.
    */
    async boolean(value: boolean, abortSignal?: AbortSignal): Promise<boolean> {
        return this._client._doRequest({
            arg: value, method: "echo.boolean",
            mutation: false,
        }, abortSignal);
    }

    get hello(): APIV1EchoHelloClient {
        return new APIV1EchoHelloClient(this._client);
    }

    /**
    This is a echo function with a number returning a string.
    */
    async itoa(value: number, abortSignal?: AbortSignal): Promise<string> {
        return this._client._doRequest({
            arg: value, method: "echo.itoa",
            mutation: false,
        }, abortSignal);
    }

    /**
    This is a echo function with a number returning a number.
    */
    async number(value: number, abortSignal?: AbortSignal): Promise<number> {
        return this._client._doRequest({
            arg: value, method: "echo.number",
            mutation: false,
        }, abortSignal);
    }
}

/**
This is API V1. Hello World!
*/
export class APIV1Client extends BaseClient<APIV1Batcher> {
    constructor(hostname?: string) {
        const headers = {};
        if (!hostname) {
            hostname = "https://example.com/";
        }
        
        super(hostname, "version=v1", headers, APIV1Batcher);
    }

    get echo(): APIV1EchoClient {
        // @ts-expect-error: The request method on this client is protected.
        return new APIV1EchoClient(this);
    }

    /**
    This is a inputless function returning a void.
    */
    async inputless(abortSignal?: AbortSignal): Promise<null> {
        return this._doRequest({
            arg: null, method: "inputless",
            mutation: false,
        }, abortSignal);
    }

    /**
    This is a root function with a string returning a void.
    */
    async root(name: string, abortSignal?: AbortSignal): Promise<null> {
        return this._doRequest({
            arg: name, method: "root",
            mutation: false,
        }, abortSignal);
    }
}

class APIV2Batcher {}

/**
This is authentication without a default.
*/
export class APIV2Client extends BaseClient<APIV2Batcher> {
    constructor(auth?: {token: string; tokenType: "BEARER" | "BOT"}, hostname?: string) {
        const types = {
            "BEARER": "Bearer",
            "BOT": "Bot",
        };
        const headers: {[key: string]: string} = {};
        if (auth) {
            headers.Authorization = types[auth.tokenType] + " " + auth.token;
        }
        if (!hostname) {
            hostname = "http://memes.com/";
        }
        
        super(hostname, "version=v2", headers, APIV2Batcher);
    }
}

class APIV3Batcher {}

/**
This is authentication with a default.
*/
export class APIV3Client extends BaseClient<APIV3Batcher> {
    constructor(token?: string, tokenType?: "BEARER" | "BOT", hostname?: string) {
        const types = {
            "BEARER": "Bearer",
            "BOT": "Bot",
        };
        if (!tokenType) {
            tokenType = "BEARER";
        }
        const headers: {[key: string]: string} = {};
        if (token) {
            headers.Authorization = types[tokenType] + " " + token;
        }
        if (!hostname) {
            hostname = "http://memes.com/";
        }
        
        super(hostname, "version=v3", headers, APIV3Batcher);
    }
}
