// This file was auto-generated by arpc. Do not edit this file.

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"unsafe"

	"github.com/vmihailenco/msgpack/v5"
)

// Defines the base that all clients will call.
type clientBase struct {
	c       *http.Client
	url     string
	headers map[string]string
}

// BatchError is a batch of errors that can be returned from a batch request.
type BatchError struct {
	// Errors is a list of errors that were returned from the batch request.
	Errors []error
}

// Error implements the error interface.
func (b BatchError) Error() string {
	e := ""
	for i, err := range b.Errors {
		if i != 0 {
			e += ", "
		}
		e += err.Error()
	}
	return e
}

// Defines the error response body.
type errorResponse struct {
	BuiltIn bool               `msgpack:"builtIn"`
	Name    string             `msgpack:"name"`
	Code    string             `msgpack:"code,omitempty"`
	Message string             `msgpack:"message"`
	Body    msgpack.RawMessage `msgpack:"body,omitempty"`
}

// BaseError is the base error that all errors will implement.
type BaseError struct{}

// Error implements the error interface.
func (b BaseError) Error() string {
	return "arpc error"
}

// InvalidResponse is an error that is returned when the response is not what
// is expected from this protocol.
type InvalidResponse struct {
	BaseError

	Code    string `json:"code"`
	Message string `json:"message"`
}

// Error implements the error interface.
func (i InvalidResponse) Error() string {
	return i.Message
}

// UnknownError is an error that is returned when the error is not known.
type UnknownError struct {
	BaseError

	Name    string             `json:"name"`
	Code    string             `json:"code"`
	Message string             `json:"message"`
	Body    msgpack.RawMessage `json:"-"`
}

// Error implements the error interface.
func (u UnknownError) Error() string {
	msg := "unknown exception (" + u.Name + ")"
	if u.Message != "" {
		msg += ": " + u.Message
	}
	return msg
}

var builtInErrors = map[string]func(
	code, message string, body msgpack.RawMessage,
) error{
	"InvalidResponse": func(code, message string, _ msgpack.RawMessage) error {
		return InvalidResponse{
			Code:    code,
			Message: message,
		}
	},
}

var customErrors = map[string]func(msgpack.RawMessage) error{}

// Used when there isn't a body all around the place.
var msgpackNull = []byte{0xc0}

// Processes an error response and turns it into an error.
func processError(e errorResponse) error {
	body := e.Body
	if body == nil {
		body = msgpackNull
	}

	if e.BuiltIn {
		if f, ok := builtInErrors[e.Name]; ok {
			return f(e.Code, e.Message, body)
		}
		return UnknownError{
			Name:    e.Name,
			Code:    e.Code,
			Message: e.Message,
			Body:    body,
		}
	}

	if f, ok := customErrors[e.Name]; ok {
		return f(body)
	}
	return UnknownError{
		Name: e.Name,
		Body: body,
	}
}

// Defines the request that will be sent to the server.
type request struct {
	method   string
	arg      any
	mutation bool
	mutator  func([]byte) (any, error)
}

// The main function to perform the network request.
func (c *clientBase) do(ctx context.Context, req any) (any, error) {
	urlCpy := c.url

	var body any
	reqType := "POST"
	switch r := req.(type) {
	case request:
		if !r.mutation {
			reqType = "GET"
		}
		body = r.arg
		urlCpy += "&route=" + r.method
	case []*request:
		allNonMutators := true
		type batchItem struct {
			MethodName string `msgpack:"methodName"`
			Arg        any    `msgpack:"arg"`
		}
		a := make([]batchItem, len(r))
		for i, req := range r {
			if req.mutation {
				allNonMutators = false
			}
			a[i] = batchItem{
				MethodName: req.method,
				Arg:        req.arg,
			}
		}
		if allNonMutators {
			reqType = "GET"
		}
		body = a
		urlCpy += "&route=batch"
	default:
		panic("unknown request type")
	}

	reqBody, err := msgpack.Marshal(body)
	if err != nil {
		return nil, err
	}
	var reader io.Reader
	if reqType == "GET" {
		esc := url.QueryEscape(unsafe.String(&reqBody[0], len(reqBody)))
		urlCpy += "&arg=" + esc
	} else {
		reader = bytes.NewReader(reqBody)
	}

	httpReq, err := http.NewRequestWithContext(ctx, reqType, urlCpy, reader)
	if err != nil {
		return nil, err
	}
	if reqType == "POST" {
		httpReq.Header.Set("Content-Type", "application/x-msgpack")
	}
	for k, v := range c.headers {
		httpReq.Header.Set(k, v)
	}

	httpResp, err := c.c.Do(httpReq)
	if err != nil {
		return nil, err
	}
	defer httpResp.Body.Close()

	if httpReq.Header.Get("x-is-arpc") != "true" {
		return nil, processError(errorResponse{
			BuiltIn: true,
			Name:    "InvalidResponse",
			Code:    "INVALID_RESPONSE",
			Message: "The response is not an arpc response.",
			Body:    msgpackNull,
		})
	}

	if httpResp.StatusCode == http.StatusNoContent {
		switch r := req.(type) {
		case request:
			return r.mutator(msgpackNull)
		case []*request:
			a := make([]any, len(r))
			for i, req := range r {
				a[i], err = req.mutator(msgpackNull)
				if err != nil {
					return nil, err
				}
			}
			return a, nil
		default:
			panic("unknown request type")
		}
	}

	bodyData, err := io.ReadAll(httpResp.Body)
	if err != nil {
		return nil, err
	}

	if httpResp.StatusCode == http.StatusOK {
		switch r := req.(type) {
		case request:
			return r.mutator(bodyData)
		case []*request:
			var raws []msgpack.RawMessage
			err = msgpack.Unmarshal(bodyData, &raws)
			if err != nil {
				return nil, err
			}
			a := make([]any, len(r))
			for i, raw := range raws {
				a[i], err = r[i].mutator(raw)
				if err != nil {
					return nil, err
				}
			}
			return a, nil
		default:
			panic("unknown request type")
		}
	}

	var errs []errorResponse
	err = msgpack.Unmarshal(bodyData, &errs)
	if err != nil {
		var single errorResponse
		err = msgpack.Unmarshal(bodyData, &single)
		if err != nil {
			return nil, err
		}
		return nil, processError(single)
	}
	errsIface := make([]error, len(errs))
	for i, e := range errs {
		errsIface[i] = processError(e)
	}
	return nil, BatchError{Errors: errsIface}
}

type apiVv1EchoHelloWorldBatcher struct {
	reqs *[]*request
}

// test void function.
func (c *apiVv1EchoHelloWorldBatcher) test() {
internalMutator := func(val []byte) (any, error) {
		var internalVal *struct{}
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "echo.hello.world.test",
		arg:	  nil,
		mutation: true,
		mutator:  internalMutator,
	}
	*c.reqs = append(*c.reqs, reqBuildObj)
}

func newApiVv1EchoHelloWorldBatcher(reqs *[]*request) *apiVv1EchoHelloWorldBatcher {
	s := &apiVv1EchoHelloWorldBatcher{reqs: reqs}
	return s
}

type apiVv1EchoHelloBatcher struct {
	reqs *[]*request

	World *apiVv1EchoHelloWorldBatcher
}

// string this is a echo function with hello returning a string.
func (c *apiVv1EchoHelloBatcher) string(value string) {
internalMutator := func(val []byte) (any, error) {
		var internalVal string
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "echo.hello.string",
		arg:	  value,
		mutation: true,
		mutator:  internalMutator,
	}
	*c.reqs = append(*c.reqs, reqBuildObj)
}

func newApiVv1EchoHelloBatcher(reqs *[]*request) *apiVv1EchoHelloBatcher {
	s := &apiVv1EchoHelloBatcher{reqs: reqs}
	s.World = newApiVv1EchoHelloWorldBatcher(s.reqs)
	return s
}

type apiVv1EchoBatcher struct {
	reqs *[]*request

	Hello *apiVv1EchoHelloBatcher
}

// boolean this is a echo function with a boolean returning a boolean.
func (c *apiVv1EchoBatcher) boolean(value bool) {
internalMutator := func(val []byte) (any, error) {
		var internalVal bool
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "echo.boolean",
		arg:	  value,
		mutation: false,
		mutator:  internalMutator,
	}
	*c.reqs = append(*c.reqs, reqBuildObj)
}

// itoa this is a echo function with a number returning a string.
func (c *apiVv1EchoBatcher) itoa(value int) {
internalMutator := func(val []byte) (any, error) {
		var internalVal string
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "echo.itoa",
		arg:	  value,
		mutation: false,
		mutator:  internalMutator,
	}
	*c.reqs = append(*c.reqs, reqBuildObj)
}

// number this is a echo function with a number returning a number.
func (c *apiVv1EchoBatcher) number(value int) {
internalMutator := func(val []byte) (any, error) {
		var internalVal int
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "echo.number",
		arg:	  value,
		mutation: false,
		mutator:  internalMutator,
	}
	*c.reqs = append(*c.reqs, reqBuildObj)
}

func newApiVv1EchoBatcher(reqs *[]*request) *apiVv1EchoBatcher {
	s := &apiVv1EchoBatcher{reqs: reqs}
	s.Hello = newApiVv1EchoHelloBatcher(s.reqs)
	return s
}

type apiVv1Batcher struct {
	base *clientBase
	reqs *[]*request

	Echo *apiVv1EchoBatcher
}

// inputless this is a inputless function returning a void.
func (c *apiVv1Batcher) inputless() {
internalMutator := func(val []byte) (any, error) {
		var internalVal *struct{}
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "inputless",
		arg:	  nil,
		mutation: false,
		mutator:  internalMutator,
	}
	*c.reqs = append(*c.reqs, reqBuildObj)
}

// root this is a root function with a string returning a void.
func (c *apiVv1Batcher) root(name string) {
internalMutator := func(val []byte) (any, error) {
		var internalVal *struct{}
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "root",
		arg:	  name,
		mutation: false,
		mutator:  internalMutator,
	}
	*c.reqs = append(*c.reqs, reqBuildObj)
}

func newApiVv1Batcher(base *clientBase) *apiVv1Batcher {
	s := &apiVv1Batcher{base: base, reqs: &[]*request{}}
	s.Echo = newApiVv1EchoBatcher(s.reqs)
	return s
}

type apiVv1EchoHelloWorldClient struct {
	base *clientBase
}

// test void function.
func (c *apiVv1EchoHelloWorldClient) test(ctx context.Context) (*struct{}, error) {
internalMutator := func(val []byte) (any, error) {
		var internalVal *struct{}
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "echo.hello.world.test",
		arg:	  nil,
		mutation: true,
		mutator:  internalMutator,
	}
   internalRes, internalErr := c.base.do(ctx, reqBuildObj)
	if internalErr != nil {
		var internalDefault *struct{}
		return internalDefault, internalErr
	}
	return internalRes.(*struct{}), nil
}

func newApiVv1EchoHelloWorldClient(base *clientBase) *apiVv1EchoHelloWorldClient {
	s := &apiVv1EchoHelloWorldClient{base: base}
	return s
}

type apiVv1EchoHelloClient struct {
	base *clientBase

	World *apiVv1EchoHelloWorldClient
}

// string this is a echo function with hello returning a string.
func (c *apiVv1EchoHelloClient) string(ctx context.Context, value string) (string, error) {
internalMutator := func(val []byte) (any, error) {
		var internalVal string
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "echo.hello.string",
		arg:	  value,
		mutation: true,
		mutator:  internalMutator,
	}
   internalRes, internalErr := c.base.do(ctx, reqBuildObj)
	if internalErr != nil {
		var internalDefault string
		return internalDefault, internalErr
	}
	return internalRes.(string), nil
}

func newApiVv1EchoHelloClient(base *clientBase) *apiVv1EchoHelloClient {
	s := &apiVv1EchoHelloClient{base: base}
	s.World = newApiVv1EchoHelloWorldClient(base)
	return s
}

type apiVv1EchoClient struct {
	base *clientBase

	Hello *apiVv1EchoHelloClient
}

// boolean this is a echo function with a boolean returning a boolean.
func (c *apiVv1EchoClient) boolean(ctx context.Context, value bool) (bool, error) {
internalMutator := func(val []byte) (any, error) {
		var internalVal bool
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "echo.boolean",
		arg:	  value,
		mutation: false,
		mutator:  internalMutator,
	}
   internalRes, internalErr := c.base.do(ctx, reqBuildObj)
	if internalErr != nil {
		var internalDefault bool
		return internalDefault, internalErr
	}
	return internalRes.(bool), nil
}

// itoa this is a echo function with a number returning a string.
func (c *apiVv1EchoClient) itoa(ctx context.Context, value int) (string, error) {
internalMutator := func(val []byte) (any, error) {
		var internalVal string
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "echo.itoa",
		arg:	  value,
		mutation: false,
		mutator:  internalMutator,
	}
   internalRes, internalErr := c.base.do(ctx, reqBuildObj)
	if internalErr != nil {
		var internalDefault string
		return internalDefault, internalErr
	}
	return internalRes.(string), nil
}

// number this is a echo function with a number returning a number.
func (c *apiVv1EchoClient) number(ctx context.Context, value int) (int, error) {
internalMutator := func(val []byte) (any, error) {
		var internalVal int
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "echo.number",
		arg:	  value,
		mutation: false,
		mutator:  internalMutator,
	}
   internalRes, internalErr := c.base.do(ctx, reqBuildObj)
	if internalErr != nil {
		var internalDefault int
		return internalDefault, internalErr
	}
	return internalRes.(int), nil
}

func newApiVv1EchoClient(base *clientBase) *apiVv1EchoClient {
	s := &apiVv1EchoClient{base: base}
	s.Hello = newApiVv1EchoHelloClient(base)
	return s
}

// APIVv1Client defines this is API V1. Hello World! Please use NewAPIVv1Client to create a new instance.
type APIVv1Client struct {
	base *clientBase

	Echo *apiVv1EchoClient
}

// inputless this is a inputless function returning a void.
func (c *APIVv1Client) inputless(ctx context.Context) (*struct{}, error) {
internalMutator := func(val []byte) (any, error) {
		var internalVal *struct{}
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "inputless",
		arg:	  nil,
		mutation: false,
		mutator:  internalMutator,
	}
   internalRes, internalErr := c.base.do(ctx, reqBuildObj)
	if internalErr != nil {
		var internalDefault *struct{}
		return internalDefault, internalErr
	}
	return internalRes.(*struct{}), nil
}

// root this is a root function with a string returning a void.
func (c *APIVv1Client) root(ctx context.Context, name string) (*struct{}, error) {
internalMutator := func(val []byte) (any, error) {
		var internalVal *struct{}
		if internalErr := msgpack.Unmarshal(val, &internalVal); internalErr != nil {
			return nil, internalErr
		}
		return internalVal, nil
	}
   reqBuildObj := request{
		method:   "root",
		arg:	  name,
		mutation: false,
		mutator:  internalMutator,
	}
   internalRes, internalErr := c.base.do(ctx, reqBuildObj)
	if internalErr != nil {
		var internalDefault *struct{}
		return internalDefault, internalErr
	}
	return internalRes.(*struct{}), nil
}

func newApiVv1Client(base *clientBase) *APIVv1Client {
	s := &APIVv1Client{base: base}
	s.Echo = newApiVv1EchoClient(base)
	return s
}

// Execute executes the batch request.
func (c *apiVv1Batcher) Execute(ctx context.Context) ([]any, error) {
	resp, err := c.base.do(ctx, *c.reqs)
	if err != nil {
		return nil, err
	}
	return resp.([]any), nil
}

// Batcher returns a new batcher for the API.
func (c *APIVv1Client) Batcher() *apiVv1Batcher {
	return newApiVv1Batcher(c.base)
}

// APIV1Opts defines the options for the API client.
type APIV1Opts struct {
	// Client is the HTTP client to use. If left blank, defaults to http.DefaultClient.
	Client *http.Client `json:"client"`

	// Hostname is the hostname to connect to. If left blank, defaults to example.com.
	Hostname string `json:"hostname"`
}

// NewAPIV1Client creates a new API client.
func NewAPIV1Client(opts APIV1Opts) (*APIV1Client, error) {
	if opts.Hostname == "" {
		opts.Hostname = "https://example.com"
	}

	protoStep := 0
apiv1ClientProtoLoop:
	for _, v := range opts.Hostname {
		switch v {
		case ':':
			protoStep = 1
		case '/':
			if protoStep != 0 {
				protoStep++
			}
			if protoStep == 3 {
				break apiv1ClientProtoLoop
			}
		default:
			protoStep = 0
		}
	}
	if protoStep != 3 {
		opts.Hostname = "https://" + opts.Hostname
	}

	u, err := url.Parse(opts.Hostname)
	if err != nil {
		return nil, err
	}
	u.Path = "/api/rpc"
	u.RawQuery = "version=v1"
	urlStr := u.String()

	httpClient := opts.Client
	if httpClient == nil {
		httpClient = http.DefaultClient
	}

	c := &clientBase{
		c:   httpClient,
		url: urlStr,
	}
	return newApiV1Client(c), nil
}

type apiVv2Batcher struct {
	base *clientBase
	reqs *[]*request
}

func newApiVv2Batcher(base *clientBase) *apiVv2Batcher {
	s := &apiVv2Batcher{base: base, reqs: &[]*request{}}
	return s
}

// APIVv2Client defines this is authentication without a default. Please use NewAPIVv2Client to create a new instance.
type APIVv2Client struct {
	base *clientBase
}

func newApiVv2Client(base *clientBase) *APIVv2Client {
	s := &APIVv2Client{base: base}
	return s
}

// Execute executes the batch request.
func (c *apiVv2Batcher) Execute(ctx context.Context) ([]any, error) {
	resp, err := c.base.do(ctx, *c.reqs)
	if err != nil {
		return nil, err
	}
	return resp.([]any), nil
}

// Batcher returns a new batcher for the API.
func (c *APIVv2Client) Batcher() *apiVv2Batcher {
	return newApiVv2Batcher(c.base)
}

// APIV2TokenType defines the type that all token types will use.
type APIV2TokenType string

const (
    // APIV2TokenTypeBEARER is the token type for BEARER.
	APIV2TokenTypeBEARER APIV2TokenType = "Bearer"

    // APIV2TokenTypeBOT is the token type for BOT.
	APIV2TokenTypeBOT APIV2TokenType = "Bot"
)

// APIV2OptsAuth defines the options for the API client with authentication.
type APIV2OptsAuth struct {
	// Token defines the token to use for authentication. Will error if not set.
	Token string `json:"token"`

	// TokenType defines the type of token to use for authentication. Will error if not set.
	TokenType APIV2TokenType `json:"token_type"`
}

func (o APIV2OptsAuth) str() (string, error) {
	if o.Token == "" {
		return "", errors.New("token is required")
	}

	if o.TokenType == "" {
		return "", errors.New("token type is required")
	}

	typeMapping := map[APIV2TokenType]string{
		APIV2TokenTypeBEARER: "Bearer",
		APIV2TokenTypeBOT: "Bot",
	}
	webTerm, ok := typeMapping[o.TokenType]
	if !ok {
		return "", errors.New("invalid token type")
	}

	return webTerm + " " + o.Token, nil
}

// APIV2Opts defines the options for the API client.
type APIV2Opts struct {
	// Authentication is the authentication options to use. If nil, no authentication is used.
	Authentication *APIV2OptsAuth `json:"authentication"`

	// Client is the HTTP client to use. If left blank, defaults to http.DefaultClient.
	Client *http.Client `json:"client"`

	// Hostname is the hostname to connect to. If left blank, defaults to memes.com.
	Hostname string `json:"hostname"`
}

// NewAPIV2Client creates a new API client.
func NewAPIV2Client(opts APIV2Opts) (*APIV2Client, error) {
	if opts.Hostname == "" {
		opts.Hostname = "http://memes.com"
	}

	protoStep := 0
apiv2ClientProtoLoop:
	for _, v := range opts.Hostname {
		switch v {
		case ':':
			protoStep = 1
		case '/':
			if protoStep != 0 {
				protoStep++
			}
			if protoStep == 3 {
				break apiv2ClientProtoLoop
			}
		default:
			protoStep = 0
		}
	}
	if protoStep != 3 {
		opts.Hostname = "http://" + opts.Hostname
	}

	u, err := url.Parse(opts.Hostname)
	if err != nil {
		return nil, err
	}
	u.Path = "/api/rpc"
	u.RawQuery = "version=v2"
	urlStr := u.String()

	httpClient := opts.Client
	if httpClient == nil {
		httpClient = http.DefaultClient
	}

	headers := map[string]string{}
	if opts.Authentication != nil {
		auth, err := opts.Authentication.str()
		if err != nil {
			return nil, err
		}
		headers["Authorization"] = auth
	}

	c := &clientBase{
		c:       httpClient,
		url:     urlStr,
		headers: headers,
	}
	return newApiV2Client(c), nil
}

type apiVv3Batcher struct {
	base *clientBase
	reqs *[]*request
}

func newApiVv3Batcher(base *clientBase) *apiVv3Batcher {
	s := &apiVv3Batcher{base: base, reqs: &[]*request{}}
	return s
}

// APIVv3Client defines this is authentication with a default. Please use NewAPIVv3Client to create a new instance.
type APIVv3Client struct {
	base *clientBase
}

func newApiVv3Client(base *clientBase) *APIVv3Client {
	s := &APIVv3Client{base: base}
	return s
}

// Execute executes the batch request.
func (c *apiVv3Batcher) Execute(ctx context.Context) ([]any, error) {
	resp, err := c.base.do(ctx, *c.reqs)
	if err != nil {
		return nil, err
	}
	return resp.([]any), nil
}

// Batcher returns a new batcher for the API.
func (c *APIVv3Client) Batcher() *apiVv3Batcher {
	return newApiVv3Batcher(c.base)
}

// APIV3TokenType defines the type that all token types will use.
type APIV3TokenType string

const (
    // APIV3TokenTypeBEARER is the token type for BEARER.
	APIV3TokenTypeBEARER APIV3TokenType = "Bearer"

    // APIV3TokenTypeBOT is the token type for BOT.
	APIV3TokenTypeBOT APIV3TokenType = "Bot"
)

// APIV3OptsAuth defines the options for the API client with authentication.
type APIV3OptsAuth struct {
	// Token defines the token to use for authentication. Will error if not set.
	Token string `json:"token"`

	// TokenType defines the type of token to use for authentication. Defaults to BEARER.
	TokenType APIV3TokenType `json:"token_type"`
}

func (o APIV3OptsAuth) str() (string, error) {
	if o.Token == "" {
		return "", errors.New("token is required")
	}

	if o.TokenType == "" {
		o.TokenType = APIV3TokenTypeBEARER
	}

	typeMapping := map[APIV3TokenType]string{
		APIV3TokenTypeBEARER: "Bearer",
		APIV3TokenTypeBOT: "Bot",
	}
	webTerm, ok := typeMapping[o.TokenType]
	if !ok {
		return "", errors.New("invalid token type")
	}

	return webTerm + " " + o.Token, nil
}

// APIV3Opts defines the options for the API client.
type APIV3Opts struct {
	// Authentication is the authentication options to use. If nil, no authentication is used.
	Authentication *APIV3OptsAuth `json:"authentication"`

	// Client is the HTTP client to use. If left blank, defaults to http.DefaultClient.
	Client *http.Client `json:"client"`

	// Hostname is the hostname to connect to. If left blank, defaults to memes.com.
	Hostname string `json:"hostname"`
}

// NewAPIV3Client creates a new API client.
func NewAPIV3Client(opts APIV3Opts) (*APIV3Client, error) {
	if opts.Hostname == "" {
		opts.Hostname = "http://memes.com"
	}

	protoStep := 0
apiv3ClientProtoLoop:
	for _, v := range opts.Hostname {
		switch v {
		case ':':
			protoStep = 1
		case '/':
			if protoStep != 0 {
				protoStep++
			}
			if protoStep == 3 {
				break apiv3ClientProtoLoop
			}
		default:
			protoStep = 0
		}
	}
	if protoStep != 3 {
		opts.Hostname = "http://" + opts.Hostname
	}

	u, err := url.Parse(opts.Hostname)
	if err != nil {
		return nil, err
	}
	u.Path = "/api/rpc"
	u.RawQuery = "version=v3"
	urlStr := u.String()

	httpClient := opts.Client
	if httpClient == nil {
		httpClient = http.DefaultClient
	}

	headers := map[string]string{}
	if opts.Authentication != nil {
		auth, err := opts.Authentication.str()
		if err != nil {
			return nil, err
		}
		headers["Authorization"] = auth
	}

	c := &clientBase{
		c:       httpClient,
		url:     urlStr,
		headers: headers,
	}
	return newApiV3Client(c), nil
}
