# This file is auto-generated by arpc. Do not edit manually!

import msgpack
import typing
import urllib.parse
import requests

_custom_exceptions = {}
_builtin_exceptions = {}


def _add_exception_cls(builtin: bool):
    def decorator(cls):
        if builtin:
            _builtin_exceptions[cls.__name__] = cls
        else:
            _custom_exceptions[cls.__name__] = cls
        return cls
    return decorator


class _Request(object):
    """Defines a request."""
    def __init__(self, method: str, mutation: bool, arg):
        self.method = method
        self.mutation = mutation
        self.arg = arg


class ClientException(Exception):
    """Defines a base exception."""
    def __init__(self, code: str, message: str, body=None):
        self.code = code
        self.message = message
        self.body = body
    
    
class _BaseCustomException(ClientException):
    """Defines the base custom exception."""
    def __init__(self, body):
        self.body = body


@_add_exception_cls(True)
class InvalidResponse(ClientException):
    """Defines an invalid response exception."""


class BatchError(ClientException):
    """Defines a batch error exception."""
    def __init__(self, errors):
        self.errors = errors

    def __str__(self):
        return f"BatchError(errors={self.errors})"


def _throw(body):
    if body.get("builtIn"):
        cls = _builtin_exceptions.get(body["name"])
        if cls:
            raise cls(body["code"], body["message"], body["body"])

        raise ClientException(body["code"], body["message"], body["body"])

    cls = _custom_exceptions.get(body["name"])
    if cls:
        raise cls(body["body"])

    raise ClientException("UNKNOWN_EXCEPTION", f"The exception '{body['name']}' is missing.", body)


class _BaseBatcher(object):
    """Defines the base batcher that all batchers inherit from."""
    def __init__(self, client):
        self._batch = []
        self._client = client

    async def execute(self):
        """Executes the batch."""
        return await self._client._do_request(self)


def _all_non_mutation(batch):
    for req in batch:
        if req[0].mutation:
            return False
    return True


def _process_batch(body, batch):
    for i, req in enumerate(batch):
        if req[1] is not None:
            body[i] = req[1](body[i])
    return body


def _arr_mutations(mutator):
    def fn(arr):
        if not isinstance(arr, list):
            return None
        return [mutator(x) for x in arr]
    return fn


def _dict_mutations(key_mutator, value_mutator):
    if not key_mutator:
        key_mutator = lambda x: x
    if not value_mutator:
        value_mutator = lambda x: x

    def fn(d):
        if not isinstance(d, dict):
            return None
        return {key_mutator(k): value_mutator(v) for k, v in d.items()}

    return fn


_actually_none = object()


def _is_none(obj):
    if obj is None:
        return _actually_none
    return None


def _process_union(*signatures):
    def fn(obj):
        for sig in signatures:
            res = sig(obj)
            if res is not None:
                if res is _actually_none:
                    return None
                return res
        raise ValueError("No union types matched.")

    return fn


def _is_type(t):
    def fn(obj):
        if isinstance(obj, t):
            return obj

        if hasattr(t, "__origin__") and t.__origin__ == list:
            if isinstance(obj, list):
                return [_is_type(t.__args__[0])(x) for x in obj]
            return None

        if hasattr(t, "__origin__") and t.__origin__ == dict:
            if isinstance(obj, dict):
                o = {}
                for k, v in obj.items():
                    k = _is_type(t.__args__[0])(k)
                    v = _is_type(t.__args__[1])(v)
                    if k is None or v is None:
                        return None
                    o[k] = v
                return o
            return None

        if hasattr(t, "__args__") and len(t.__args__) > 0:
            for arg in t.__args__:
                if obj == arg:
                    return obj
            return None

        return None

    return fn


def _is_eq(value):
    def fn(obj):
        if obj == value:
            return obj
        return None
    return fn


def _process_result(resp: requests.Response, batch):
    """Processes the result of a request."""
    if resp.headers.get("X-Is-Arpc") != "true":
        raise InvalidResponse("INVALID_RESPONSE", "The response is not an arpc response.")

    if resp.status_code == 204:
        return None if batch is None else [None] * len(batch)

    try:
        body = msgpack.unpackb(resp.content, raw=False)
    except ValueError:
        raise InvalidResponse("INVALID_RESPONSE", "The response is not a valid msgpack response.")

    if resp.status_code == 200:
        if not batch:
            return body
        return _process_batch(body, batch)

    if isinstance(body, list):
        errors = []
        for error in body:
            try:
                _throw(error)
            except Exception as e:
                errors.append(e)
        raise BatchError(errors)

    _throw(body)


class _BaseClient(object):
    """Defines the base client that all clients inherit from."""
    def __init__(self, url_params: str, hostname: str, init_headers):
        self._url_params = url_params
        self._hostname = hostname
        self._init_headers = init_headers

    def _do_request(self, request: typing.Union[_Request, _BaseBatcher]):
        """Executes a request."""
        m = "POST"
        headers = self._init_headers.copy()
        kwargs = {}
        batch = None
        if isinstance(request, _Request):
            # Handle a single request.
            params = self._url_params + "&route=" + urllib.parse.quote_plus(request.method)
            if request.mutation:
                # Send the msgpack as the body.
                headers["Content-Type"] = "application/msgpack"
                kwargs["data"] = msgpack.packb(request.arg)
            else:
                # Include the argument in the query string.
                m = "GET"
                arg = urllib.parse.quote_plus(msgpack.packb(request.arg))
                params = params + f"&arg={arg}"
        else:
            # Handle a batch request.
            batch = request._batch
            params = self._url_params + "&route=batch"
            data = msgpack.packb([{"methodName": req[0].method, "arg": req[0].arg} for req in batch])
            if _all_non_mutation(batch):
                # Include the argument in the query string.
                m = "GET"
                arg = urllib.parse.quote_plus(data)
                params = params + f"&arg={arg}"
            else:
                # Send the msgpack as the body.
                headers["Content-Type"] = "application/msgpack"
                kwargs["data"] = data

        resp = requests.request(m, self._hostname + "/api/rpc?" + params, headers=headers, **kwargs)
        return _process_result(resp, batch)


class _BatcherAPIV1EchoHelloWorld(object):
    def __init__(self, batch):
        """Sets up the category."""
        self._batch = batch

    def test(self) -> None:
        """Void function."""
        self._batch.append((_Request(
            "echo.hello.world.test", True, None), None))


class _BatcherAPIV1EchoHello(object):
    def __init__(self, batch):
        """Sets up the category."""
        self._batch = batch
        self.world = _BatcherAPIV1EchoHelloWorld(self._batch)

    def string(self, value: str) -> None:
        """This is a echo function with hello returning a string."""
        self._batch.append((_Request(
            "echo.hello.string", True, value), None))


class _BatcherAPIV1Echo(object):
    def __init__(self, batch):
        """Sets up the category."""
        self._batch = batch
        self.hello = _BatcherAPIV1EchoHello(self._batch)

    def boolean(self, value: bool) -> None:
        """This is a echo function with a boolean returning a boolean."""
        self._batch.append((_Request(
            "echo.boolean", False, value), None))

    def itoa(self, value: int) -> None:
        """This is a echo function with a number returning a string."""
        self._batch.append((_Request(
            "echo.itoa", False, value), None))

    def number(self, value: int) -> None:
        """This is a echo function with a number returning a number."""
        self._batch.append((_Request(
            "echo.number", False, value), None))


class _BatcherAPIV1(_BaseBatcher):
    def __init__(self, client):
        super().__init__(client)
        self.echo = _BatcherAPIV1Echo(self._batch)

    def inputless(self) -> None:
        """This is a inputless function returning a void."""
        self._batch.append((_Request(
            "inputless", False, None), None))

    def root(self, name: str) -> None:
        """This is a root function with a string returning a void."""
        self._batch.append((_Request(
            "root", False, name), None))


class _APIV1EchoHelloWorldClient(object):
    def __init__(self, client):
        """Sets up the category."""
        self._client = client

    def test(self) -> None:
        """Void function."""
        return self._client._do_request(_Request(
            "echo.hello.world.test", True, None))


class _APIV1EchoHelloClient(object):
    def __init__(self, client):
        """Sets up the category."""
        self._client = client
        self.world = _APIV1EchoHelloWorldClient(client)

    def string(self, value: str) -> str:
        """This is a echo function with hello returning a string."""
        return self._client._do_request(_Request(
            "echo.hello.string", True, value))


class _APIV1EchoClient(object):
    def __init__(self, client):
        """Sets up the category."""
        self._client = client
        self.hello = _APIV1EchoHelloClient(client)

    def boolean(self, value: bool) -> bool:
        """This is a echo function with a boolean returning a boolean."""
        return self._client._do_request(_Request(
            "echo.boolean", False, value))

    def itoa(self, value: int) -> str:
        """This is a echo function with a number returning a string."""
        return self._client._do_request(_Request(
            "echo.itoa", False, value))

    def number(self, value: int) -> int:
        """This is a echo function with a number returning a number."""
        return self._client._do_request(_Request(
            "echo.number", False, value))


class APIV1Client(_BaseClient):
    """This is API V1. Hello World!"""
    def __init__(self, hostname: str = None):
        init_headers = {}
        hostname = hostname or "https://example.com"
        parsed = urllib.parse.urlparse(hostname)
        if parsed.scheme:
            hostname = parsed.scheme + "://" + parsed.netloc
        else:
            hostname = "https://" + hostname
        
        super().__init__("version=v1", hostname, init_headers)
        self.echo = _APIV1EchoClient(self)

    def inputless(self) -> None:
        """This is a inputless function returning a void."""
        return self._do_request(_Request(
            "inputless", False, None))

    def root(self, name: str) -> None:
        """This is a root function with a string returning a void."""
        return self._do_request(_Request(
            "root", False, name))

    def batcher(self) -> _BatcherAPIV1:
        """Returns the batcher for this client."""
        return _BatcherAPIV1(self)


class _BatcherAPIV2(_BaseBatcher):
    def __init__(self, client):
        super().__init__(client)




class APIV2Client(_BaseClient):
    """This is authentication without a default."""
    def __init__(self, token: str = None, token_type: typing.Literal["BEARER", "BOT"] = None, hostname: str = None):
        init_headers = {}
        if token:
            token_type_map = {"BEARER": "Bearer", "BOT": "Bot"}
            if token_type not in token_type_map:
                raise ValueError(f"Invalid token type: {token_type}")
            init_headers = {"Authorization": f"{token_type_map[token_type]} {token}"}

        hostname = hostname or "http://memes.com"
        parsed = urllib.parse.urlparse(hostname)
        if parsed.scheme:
            hostname = parsed.scheme + "://" + parsed.netloc
        else:
            hostname = "http://" + hostname
        
        super().__init__("version=v2", hostname, init_headers)



    def batcher(self) -> _BatcherAPIV2:
        """Returns the batcher for this client."""
        return _BatcherAPIV2(self)


class _BatcherAPIV3(_BaseBatcher):
    def __init__(self, client):
        super().__init__(client)




class APIV3Client(_BaseClient):
    """This is authentication with a default."""
    def __init__(self, token: str = None, token_type: typing.Literal["BEARER", "BOT"] = "BEARER", hostname: str = None):
        init_headers = {}
        if token:
            token_type_map = {"BEARER": "Bearer", "BOT": "Bot"}
            if token_type not in token_type_map:
                raise ValueError(f"Invalid token type: {token_type}")
            init_headers = {"Authorization": f"{token_type_map[token_type]} {token}"}

        hostname = hostname or "http://memes.com"
        parsed = urllib.parse.urlparse(hostname)
        if parsed.scheme:
            hostname = parsed.scheme + "://" + parsed.netloc
        else:
            hostname = "http://" + hostname
        
        super().__init__("version=v3", hostname, init_headers)



    def batcher(self) -> _BatcherAPIV3:
        """Returns the batcher for this client."""
        return _BatcherAPIV3(self)
