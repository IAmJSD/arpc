# This file is auto-generated by @arpc/client-gen. Do not edit!

import aiohttp
import asyncio
import msgpack
import typing
import urllib.parse

_custom_exceptions = {}
_builtin_exceptions = {}


def _add_exception_cls(builtin: bool):
    def decorator(cls):
        if builtin:
            _builtin_exceptions[cls.__name__] = cls
        else:
            _custom_exceptions[cls.__name__] = cls
        return cls
    return decorator


class _Request(object):
    """Defines a request."""
    def __init__(self, method: str, mutation: bool, arg):
        self.method = method
        self.mutation = mutation
        self.arg = arg


class ClientException(Exception):
    """Defines a base exception."""
    def __init__(self, code: str, message: str, body=None):
        self.code = code
        self.message = message
        self.body = body
    
    
class _BaseCustomException(ClientException):
    """Defines the base custom exception."""
    def __init__(self, body):
        self.body = body


@_add_exception_cls(True)
class InvalidResponse(ClientException):
    """Defines an invalid response exception."""


class BatchError(ClientException):
    """Defines a batch error exception."""
    def __init__(self, errors):
        self.errors = errors

    def __str__(self):
        return f"BatchError(errors={self.errors})"


def _throw(body):
    if body.get("builtIn"):
        cls = _builtin_exceptions.get(body["name"])
        if cls:
            raise cls(body["code"], body["message"], body["body"])

        raise ClientException(body["code"], body["message"], body["body"])

    cls = _custom_exceptions.get(body["name"])
    if cls:
        raise cls(body["body"])

    raise ClientException("UNKNOWN_EXCEPTION", f"The exception '{body['name']}' is missing.", body)


class _BaseBatcher(object):
    """Defines the base batcher that all batchers inherit from."""
    def __init__(self, client):
        self._batch = []
        self._client = client

    async def execute(self):
        """Executes the batch."""
        return await self._client._do_request(self)


def _all_non_mutation(batch):
    for req in batch:
        if req[0].mutation:
            return False
    return True


def _process_batch(body, batch):
    for i, req in enumerate(batch):
        if req[1] is not None:
            body[i] = req[1](body[i])
    return body


def _arr_mutations(mutator):
    def fn(arr):
        if not isinstance(arr, list):
            return None
        return [mutator(x) for x in arr]
    return fn


def _dict_mutations(key_mutator, value_mutator):
    if not key_mutator:
        key_mutator = lambda x: x
    if not value_mutator:
        value_mutator = lambda x: x

    def fn(d):
        if not isinstance(d, dict):
            return None
        return {key_mutator(k): value_mutator(v) for k, v in d.items()}

    return fn


_actually_none = object()


def _is_none(obj):
    if obj is None:
        return _actually_none
    return None


def _process_union(*signatures):
    def fn(obj):
        for sig in signatures:
            res = sig(obj)
            if res is not None:
                if res is _actually_none:
                    return None
                return res
        raise ValueError("No union types matched.")

    return fn


def _is_type(t):
    def fn(obj):
        if isinstance(obj, t):
            return obj

        if hasattr(t, "__origin__") and t.__origin__ == list:
            if isinstance(obj, list):
                return [_is_type(t.__args__[0])(x) for x in obj]
            return None

        if hasattr(t, "__origin__") and t.__origin__ == dict:
            if isinstance(obj, dict):
                o = {}
                for k, v in obj.items():
                    k = _is_type(t.__args__[0])(k)
                    v = _is_type(t.__args__[1])(v)
                    if k is None or v is None:
                        return None
                    o[k] = v
                return o
            return None

        if hasattr(t, "__args__") and len(t.__args__) > 0:
            for arg in t.__args__:
                if obj == arg:
                    return obj
            return None

        return None

    return fn


def _is_eq(value):
    def fn(obj):
        if obj == value:
            return obj
        return None
    return fn


async def _process_result(resp: aiohttp.ClientResponse, batch):
    """Processes the result of a request."""
    if resp.headers.get("X-Is-Arpc") != "true":
        raise InvalidResponse("INVALID_RESPONSE", "The response is not an arpc response.")

    if resp.status == 204:
        return None if batch is None else [None] * len(batch)

    try:
        body = msgpack.unpackb(await resp.read(), raw=False)
    except ValueError:
        raise InvalidResponse("INVALID_RESPONSE", "The response is not a valid msgpack response.")

    if resp.status == 200:
        if not batch:
            return body
        return _process_batch(body, batch)

    if isinstance(body, list):
        errors = []
        for error in body:
            try:
                _throw(error)
            except Exception as e:
                errors.append(e)
        raise BatchError(errors)

    _throw(body)


class _BaseClient(object):
    """Defines the base client that all clients inherit from."""
    def __init__(self, url_params: str, hostname: str, init_headers, loop: asyncio.AbstractEventLoop = None):
        self._url_params = url_params
        self._hostname = hostname
        self._init_headers = init_headers
        self._loop = loop or asyncio.get_event_loop()

    async def _do_request(self, request: typing.Union[_Request, _BaseBatcher]):
        """Executes a request."""
        m = "POST"
        headers = self._init_headers.copy()
        kwargs = {}
        batch = None
        if isinstance(request, _Request):
            # Handle a single request.
            params = self._url_params + "&route=" + urllib.parse.quote_plus(request.method)
            if request.mutation:
                # Send the msgpack as the body.
                headers["Content-Type"] = "application/msgpack"
                kwargs["data"] = msgpack.packb(request.arg)
            else:
                # Include the argument in the query string.
                m = "GET"
                arg = urllib.parse.quote_plus(msgpack.packb(request.arg))
                params = params + f"&arg={arg}"
        else:
            # Handle a batch request.
            batch = request._batch
            params = self._url_params + "&route=batch"
            data = msgpack.packb([{"methodName": req[0].method, "arg": req[0].arg} for req in batch])
            if _all_non_mutation(batch):
                # Include the argument in the query string.
                m = "GET"
                arg = urllib.parse.quote_plus(data)
                params = params + f"&arg={arg}"
            else:
                # Send the msgpack as the body.
                headers["Content-Type"] = "application/msgpack"
                kwargs["data"] = data

        async with aiohttp.ClientSession(headers=headers, loop=self._loop) as session:
            async with session.request(m, f"{self._hostname}/api/rpc?{params}", **kwargs) as resp:
                return await _process_result(resp, batch)


@_add_exception_cls(True)
class TestException(ClientException):
    """This is a exception."""


@_add_exception_cls(True)
class TestException2(ClientException):
    """This is another exception."""
